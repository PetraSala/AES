AES encryption and decryption without mode of operation with an example

(* Bulding S box *)

(* First step: Building Modulo Inverse Table *)

(*Irreducible polynomial P(y) *)

P = y^8 + y^4 + y^3 + y + 1;

ListInvDec = {0};
For[i = 1, i < 256, i++,
 ExampleDec = i;
 listBinDig = IntegerDigits[ExampleDec, 2, 8];
 poly = 0;
 For[j = 1, j <= 8, j++, poly = poly + listBinDig[[j]]*y^ (8 - j)];
 {a, {ModInverse, c}} = PolynomialExtendedGCD[poly, P, Modulus -> 2];
 ModInverseDec = ModInverse /. y -> 2;
 ModInverseHex = BaseForm[ModInverseDec, 16];
 AppendTo[ListInvDec, ModInverseDec]]

sBoxInvFunction[input_] := (
  ListInvDec[[input + 1]]
  )

(* Step 2: Bulding S box with affine mapping *)

MatrixHelp1 = {{1, 0, 0, 0, 1, 1, 1, 1}, {1, 1, 0, 0, 0, 1, 1, 1}, {1, 1, 1, 
    0, 0, 0, 1, 1}, {1, 1, 1, 1, 0, 0, 0, 1}, {1, 1, 1, 1, 1, 0, 0, 0}, {0, 1,
     1, 1, 1, 1, 0, 0}, {0, 0, 1, 1, 1, 1, 1, 0}, {0, 0, 0, 1, 1, 1, 1, 1}};

MatrixHelp2 = {1, 1, 0, 0, 0, 1, 1, 0};

sBoxDec = {};
For[j = 0, j < 256, j++,
 Example = j;
 sBoxExample = ListInvDec[[Example + 1]];
 ExampleBin = IntegerDigits[sBoxExample, 2, 8];
 ExampleBinReverse = Reverse[ExampleBin];
 Mult = Mod[Dot[MatrixHelp1, ExampleBinReverse], 2];
 sumMatrix = Mod[Mult + MatrixHelp2, 2];
 AppendTo[sBoxDec, FromDigits[Reverse[sumMatrix], 2]];
 ]

sBoxFunction[input_] := (
  sBoxDec[[input + 1]]
  )

(* Function for converting binary into polynomials *)

FunctionPoly[number_] := (
  BinDig = IntegerDigits[number, 2, 8];
  poly = 0;
  For[k = 1, k <= 8, k++, poly = poly + BinDig[[k]]*y^ (8 - k)];
  poly)

(* Key Addition Layer *)

KeyGenG[v_, i_] := (
  V = v;
  V = RotateLeft[V, 1];
  V = Map[sBoxFunction, V];
  RC = PolynomialMod[y^(i - 1) , P] /. {-1 -> 1, y -> 2};
  V[[1]] = BitXor[RC, V[[1]]];
  V
  )

GenerateSubkeys[key_] := (
  W = ConstantArray[{0, 0, 0, 0}, 44];
  keyPart = Partition[key, 4];
  For[i = 1, i <= 4, i++,
   W[[i]] = keyPart[[i]]];
  For[i = 1, i < 11, i++,
   W[[i*4 + 1]] = BitXor[W[[4*(i - 1) + 1]], KeyGenG[W[[4*i]], i]];
   For[j = 1, j <= 3, j++,
    W[[4*i + j + 1]] = BitXor[W[[4*i + j]], W[[4*(i - 1) + j + 1]]]
    ]
   ];
  W
  )

(* Diffusion layer *)
(* Shifting rows *)

ShiftRows[state_] := (
  currentState = state;
  {currentState[[1]], RotateLeft[currentState[[2]]], 
   RotateLeft[currentState[[3]], 2], RotateLeft[currentState[[4]], 3]}
  )

(* Mix Columns *)

MixColumnMatrix = {{02, 03, 01, 01}, {01, 02, 03, 01}, {01, 01, 02, 03}, {03, 
    01, 01, 02}};

MixColumn[state_] := (
  newState = {};
  For[m = 1, m <= 4, m++,
   For[n = 1, n <= 4, n++,
    ColumnProduct = 0;
    For[j = 1, j <= 4, j++,
     ColumnProduct = 
      ColumnProduct + 
       Expand[FunctionPoly[MixColumnMatrix[[n, j]]]*
         FunctionPoly[state[[j, m]]]]];
    ColumnProdmod = PolynomialMod[ColumnProduct, 2];
    AppendTo[newState, ColumnProdmod]]];
  Trans = Partition[PolynomialMod[PolynomialMod[newState, P], 2] /. {y -> 2}, 
    4];
  Transpose[Trans])

(* Initializations *)

clearText = ToCharacterCode["Fun Cryptography"];
encryptionKey = 
  FromDigits[#, 16] & /@ {"2b", "7e", "15", "16" , "28", "ae", "d2", "a6", 
    "ab", "f7", "15", "88", "09", "cf", "4f", "3c"
    };


EncFunction[cleartext_, key_] := (
  state = cleartext;
  state = Transpose[Partition[state, 4]];
  
  W = GenerateSubkeys[key];
  state = BitXor[state, Transpose[Take[W, 4]]];
   
  For[i = 1, i <= 10, i++,
   state = Map[sBoxFunction, state];
   
   state = ShiftRows[state];
   
   If[i != 10, state = MixColumn[state]];
   state = BitXor[state, Transpose[Take[W, {i*4 + 1, i*4 + 4}]]];
   
   ];
  state
  )


ciphertext = EncFunction[clearText , encryptionKey];

(* Decrypt *)

(* InvShift rows *)

InvShiftRows[state_] := (
  currentState = state;
  {currentState[[1]], RotateRight[currentState[[2]]], 
   RotateRight[currentState[[3]], 2], RotateRight[currentState[[4]], 3]}
  )

(* InvMix Column *)

InvColumnMatrix = {{14, 11, 13, 09}, {09, 14, 11, 13}, {13, 09, 14, 11}, {11, 
    13, 09, 14}};

InvMixColumn[state_] := (
  sState = state;
  newState = {};
  For[m = 1, m <= 4, m++,
   For[n = 1, n <= 4, n++,
    ColumnProduct = 0;
    For[j = 1, j <= 4, j++,
     ColumnProduct = 
      ColumnProduct + 
       Expand[FunctionPoly[InvColumnMatrix[[n, j]]]*
         FunctionPoly[sState[[j, m]]]]];
    ColumnProdmod = PolynomialMod[ColumnProduct, 2];
    AppendTo[newState, ColumnProdmod]]];
  Trans = Partition[PolynomialMod[PolynomialMod[newState, P], 2] /. {y -> 2}, 
    4];
  Transpose[Trans]
  )

(* Inverse of S Box *)

sBoxInvFunction[input_] := (
  Position[sBoxDec, input][[1]][[1]] - 1
  )

(* Decryption *)

DecFunction[ciphertext_, key_] := (
  state = Partition[ciphertext, 4];
  W = GenerateSubkeys[key];
  For[z = 10, z >= 1, z--,
   state = BitXor[state, Transpose[Take[W, {z*4 + 1, z*4 + 4}]]];
   If[z != 10, state = InvMixColumn[state]];
   state = InvShiftRows[state];
   state = Map[sBoxInvFunction, state, {2}];
   ];
  state = BitXor[state, Transpose[Take[W, 4]]];
  state)

PaddedMessage[planetext_] := (
  br = -1; f = 1; 
  While[br < 0, 
   If[f*16 - Length[planetext] >= 0, 
    br = 1;
    pad = f*16 - Length[planetext], f++]];
  PaddedText = PadRight[planetext, Length[planetext] + pad];
  PaddedText
  )

EncWithPadd[planetext_, key_] := (
  Final = {};
  PaddedText = PaddedMessage[planetext];
  For[b = 0, b < f, b++,
   takePart = Take[PaddedText, {16*b + 1, 16*(b + 1)}];
   EncPart = EncFunction[takePart, key];
   Final = Join[Final, EncPart]];
  Final = Flatten[Final];
  Final
  )

DecWithPadd[ciphertext_, key_] := (
  Final = {};
  For[b = 0, b < f, b++,
   EncPart = Take[ciphertext, {16*b + 1, 16*(b + 1)}];
   DecPart = DecFunction[EncPart, key];
   DecPart = Flatten[Transpose[DecPart]];
   Final = Join[Final, DecPart]];
  FinalDec =
   FromCharacterCode[Final];
  FinalDec)

(* Example *)

message = ToCharacterCode["I love sunny days!!"];

encryptedMessage = EncWithPadd[message, encryptionKey];

decryptedMessage = DecWithPadd[encryptedMessage, encryptionKey]

"I love sunny days!!\.00\.00\.00\.00\.00\.00\.00\.00\.00\.00\.00\.00\.00"
